//! Demo sensor value generation task.
//!
//! Generates simulated sensor values using sine waves for testing
//! the dashboard display without real OBD-II hardware.

use defmt::info;
use embassy_sync::blocking_mutex::raw::CriticalSectionRawMutex;
use embassy_sync::watch::Watch;
use embassy_time::{Instant, Timer};

// =============================================================================
// Demo Sensor Values
// =============================================================================

/// All demo sensor values generated by the demo task.
#[derive(Clone, Copy, Default)]
pub struct DemoSensorValues {
    pub boost: f32,
    pub oil_temp: f32,
    pub water_temp: f32,
    pub dsg_temp: f32,
    pub iat_temp: f32,
    pub egt_temp: f32,
    pub batt_voltage: f32,
    pub afr: f32,
}

/// Watch channel for sharing demo sensor values between tasks.
/// The demo task writes, the render task reads the latest values.
/// Initialized at compile time (Watch::new() is const).
pub static DEMO_VALUES: Watch<CriticalSectionRawMutex, DemoSensorValues, 2> = Watch::new();

/// Demo values generation task - runs concurrently with rendering.
/// Generates simulated sensor values using micromath sine waves.
#[embassy_executor::task]
pub async fn demo_values_task(
    sender: embassy_sync::watch::DynSender<'static, DemoSensorValues>,
    start_time: Instant,
) {
    info!("Demo values task started");

    loop {
        // Time-based animation (independent of frame rate)
        let elapsed_ms = start_time.elapsed().as_millis() as u32;
        let t = elapsed_ms as f32 / 1000.0;

        // Generate demo values using micromath sine waves
        // Boost: peaks at 2.0 bar with a flat top (extends past 2.0 then clamps)
        let values = DemoSensorValues {
            boost: (0.3 + 2.2 * micromath::F32(t * 0.5).sin().0.abs()).min(2.0),
            oil_temp: 60.0 + 55.0 * micromath::F32(t * 0.3).sin().0,
            water_temp: 88.0 + 7.0 * micromath::F32(t * 0.4).sin().0,
            dsg_temp: 75.0 + 40.0 * micromath::F32(t * 0.35).sin().0,
            iat_temp: 30.0 + 40.0 * micromath::F32(t * 0.25).sin().0,
            egt_temp: 200.0 + 1000.0 * micromath::F32(t * 0.04).sin().0.abs(),
            batt_voltage: 12.0 + 2.5 * micromath::F32(t * 0.15).sin().0,
            afr: 14.0 + 4.0 * micromath::F32(t * 0.45).sin().0,
        };

        // Send latest values (overwrites previous if not consumed)
        sender.send(values);

        // Generate values at ~100 Hz (faster than render to ensure fresh data)
        Timer::after_millis(10).await;
    }
}
